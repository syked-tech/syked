{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport React from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { useSnackbar } from 'notistack';\nimport { removeSnackbar } from './actions';\nlet displayed = [];\n\nconst Notifier = () => {\n  _s();\n\n  const dispatch = useDispatch();\n  const notifications = useSelector(store => store.notifier.notifications || []);\n  const {\n    enqueueSnackbar,\n    closeSnackbar\n  } = useSnackbar();\n\n  const storeDisplayed = id => {\n    displayed = [...displayed, id];\n  };\n\n  const removeDisplayed = id => {\n    displayed = [...displayed.filter(key => id !== key)];\n  };\n\n  React.useEffect(() => {\n    notifications.forEach(({\n      key,\n      message,\n      options = {},\n      dismissed = false\n    }) => {\n      if (dismissed) {\n        // dismiss snackbar using notistack\n        closeSnackbar(key);\n        return;\n      } // do nothing if snackbar is already displayed\n\n\n      if (displayed.includes(key)) return; // display snackbar using notistack\n\n      enqueueSnackbar(message, {\n        key,\n        ...options,\n        onClose: (event, reason, myKey) => {\n          if (options.onClose) {\n            options.onClose(event, reason, myKey);\n          }\n        },\n        onExited: (event, myKey) => {\n          // removen this snackbar from redux store\n          dispatch(removeSnackbar(myKey));\n          removeDisplayed(myKey);\n        }\n      }); // keep track of snackbars that we've displayed\n\n      storeDisplayed(key);\n    });\n  }, [notifications, closeSnackbar, enqueueSnackbar, dispatch]);\n  return null;\n};\n\n_s(Notifier, \"DN20G4yDJckP5AKSoyrZqMSOiqY=\", false, function () {\n  return [useDispatch, useSelector, useSnackbar];\n});\n\n_c = Notifier;\nexport default Notifier;\n\nvar _c;\n\n$RefreshReg$(_c, \"Notifier\");","map":{"version":3,"sources":["/Users/lasimonne/Projects/syked.xyz/src/components/Notifier/Notifier.js"],"names":["React","useDispatch","useSelector","useSnackbar","removeSnackbar","displayed","Notifier","dispatch","notifications","store","notifier","enqueueSnackbar","closeSnackbar","storeDisplayed","id","removeDisplayed","filter","key","useEffect","forEach","message","options","dismissed","includes","onClose","event","reason","myKey","onExited"],"mappings":";;AAAA,OAAOA,KAAP,MAAkB,OAAlB;AACA,SAASC,WAAT,EAAsBC,WAAtB,QAAyC,aAAzC;AACA,SAASC,WAAT,QAA4B,WAA5B;AACA,SAASC,cAAT,QAA+B,WAA/B;AAEA,IAAIC,SAAS,GAAG,EAAhB;;AAEA,MAAMC,QAAQ,GAAG,MAAM;AAAA;;AACrB,QAAMC,QAAQ,GAAGN,WAAW,EAA5B;AACA,QAAMO,aAAa,GAAGN,WAAW,CAAEO,KAAD,IAAWA,KAAK,CAACC,QAAN,CAAeF,aAAf,IAAgC,EAA5C,CAAjC;AACA,QAAM;AAAEG,IAAAA,eAAF;AAAmBC,IAAAA;AAAnB,MAAqCT,WAAW,EAAtD;;AAEA,QAAMU,cAAc,GAAIC,EAAD,IAAQ;AAC7BT,IAAAA,SAAS,GAAG,CAAC,GAAGA,SAAJ,EAAeS,EAAf,CAAZ;AACD,GAFD;;AAIA,QAAMC,eAAe,GAAID,EAAD,IAAQ;AAC9BT,IAAAA,SAAS,GAAG,CAAC,GAAGA,SAAS,CAACW,MAAV,CAAkBC,GAAD,IAASH,EAAE,KAAKG,GAAjC,CAAJ,CAAZ;AACD,GAFD;;AAIAjB,EAAAA,KAAK,CAACkB,SAAN,CAAgB,MAAM;AACpBV,IAAAA,aAAa,CAACW,OAAd,CAAsB,CAAC;AAAEF,MAAAA,GAAF;AAAOG,MAAAA,OAAP;AAAgBC,MAAAA,OAAO,GAAG,EAA1B;AAA8BC,MAAAA,SAAS,GAAG;AAA1C,KAAD,KAAuD;AAC3E,UAAIA,SAAJ,EAAe;AACb;AACAV,QAAAA,aAAa,CAACK,GAAD,CAAb;AACA;AACD,OAL0E,CAO3E;;;AACA,UAAIZ,SAAS,CAACkB,QAAV,CAAmBN,GAAnB,CAAJ,EAA6B,OAR8C,CAU3E;;AACAN,MAAAA,eAAe,CAACS,OAAD,EAAU;AACvBH,QAAAA,GADuB;AAEvB,WAAGI,OAFoB;AAGvBG,QAAAA,OAAO,EAAE,CAACC,KAAD,EAAQC,MAAR,EAAgBC,KAAhB,KAA0B;AACjC,cAAIN,OAAO,CAACG,OAAZ,EAAqB;AACnBH,YAAAA,OAAO,CAACG,OAAR,CAAgBC,KAAhB,EAAuBC,MAAvB,EAA+BC,KAA/B;AACD;AACF,SAPsB;AAQvBC,QAAAA,QAAQ,EAAE,CAACH,KAAD,EAAQE,KAAR,KAAkB;AAC1B;AACApB,UAAAA,QAAQ,CAACH,cAAc,CAACuB,KAAD,CAAf,CAAR;AACAZ,UAAAA,eAAe,CAACY,KAAD,CAAf;AACD;AAZsB,OAAV,CAAf,CAX2E,CA0B3E;;AACAd,MAAAA,cAAc,CAACI,GAAD,CAAd;AACD,KA5BD;AA6BD,GA9BD,EA8BG,CAACT,aAAD,EAAgBI,aAAhB,EAA+BD,eAA/B,EAAgDJ,QAAhD,CA9BH;AAgCA,SAAO,IAAP;AACD,CA9CD;;GAAMD,Q;UACaL,W,EACKC,W,EACqBC,W;;;KAHvCG,Q;AAgDN,eAAeA,QAAf","sourcesContent":["import React from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { useSnackbar } from 'notistack';\nimport { removeSnackbar } from './actions';\n\nlet displayed = [];\n\nconst Notifier = () => {\n  const dispatch = useDispatch();\n  const notifications = useSelector((store) => store.notifier.notifications || []);\n  const { enqueueSnackbar, closeSnackbar } = useSnackbar();\n\n  const storeDisplayed = (id) => {\n    displayed = [...displayed, id];\n  };\n\n  const removeDisplayed = (id) => {\n    displayed = [...displayed.filter((key) => id !== key)];\n  };\n\n  React.useEffect(() => {\n    notifications.forEach(({ key, message, options = {}, dismissed = false }) => {\n      if (dismissed) {\n        // dismiss snackbar using notistack\n        closeSnackbar(key);\n        return;\n      }\n\n      // do nothing if snackbar is already displayed\n      if (displayed.includes(key)) return;\n\n      // display snackbar using notistack\n      enqueueSnackbar(message, {\n        key,\n        ...options,\n        onClose: (event, reason, myKey) => {\n          if (options.onClose) {\n            options.onClose(event, reason, myKey);\n          }\n        },\n        onExited: (event, myKey) => {\n          // removen this snackbar from redux store\n          dispatch(removeSnackbar(myKey));\n          removeDisplayed(myKey);\n        },\n      });\n\n      // keep track of snackbars that we've displayed\n      storeDisplayed(key);\n    });\n  }, [notifications, closeSnackbar, enqueueSnackbar, dispatch]);\n\n  return null;\n};\n\nexport default Notifier;\n"]},"metadata":{},"sourceType":"module"}